---
title: "DESeq2toWGCNA"
author: "Nicole Phelan"
date: "2025-10-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/users/n/m/nmphelan/projects/eco_genomics_2025/transcriptomics/mydata")
```

Importing libraries and data and do basic DESeq2 data filtering

```{r}
## Import the libraries that we're likely to need in this session

library(WGCNA)
library(DESeq2)
library(tidyverse)
library(CorLevelPlot)
library(gridExtra) 
library(Rmisc)
 
# Import the counts matrix
countsTable <- read.table("counts_matrix.txt", header=TRUE, row.names=1)
dim(countsTable)

countsTableRound <- round(countsTable) # bc DESeq2 doesn't like decimals (and Salmon outputs data with decimals)
# Corrects the column names to match between the metadata table and the counts matrix.
colnames(countsTableRound) <- substr(colnames(countsTableRound), start=1, stop = 4)

#import the sample description table
conds <- read.delim("metadata.txt", header=TRUE, stringsAsFactors = TRUE, row.names=1)


#### Create a DESeq object and define the experimental design here with the tilda

dds <- DESeqDataSetFromMatrix(countData = countsTableRound, colData=conds, 
                              design= ~ generation + line)

dim(dds)

# Filter out genes with too few reads - remove all genes with counts < 15 in more than 75% of 24 samples, so 18)
## suggested by WGCNA on RNAseq FAQ

dds <- dds[rowSums(counts(dds) >= 15) >= 18,]
nrow(dds) 

dds$line <- relevel(dds$line, ref = "control")
dds$generation <- relevel(dds$generation, ref = "G1")

dds$group <- factor(paste0(dds$line, dds$generation))
design(dds) <- ~ group
dds <- DESeq(dds)

# transform the data using variance stabilization
vsd <- vst(dds, blind=FALSE)
```

Importing the phenotypic trait data and filtering gene expression based on variance

```{r}
# Import the phenotypic data 

ULT_trait <- read.csv("WGCNA_TraitData.csv", 
                      header = TRUE, # treat the first row as a header and ignore it
                      stringsAsFactors = FALSE, # series of letters/numbers are not treated as factors
                      row.names = 1) # first column is treated as the row names
                      
# Make sure ULT_trait is a data frame
ULT_trait <- as.data.frame(ULT_trait)


#make sure you have the varience stabilized dds object 

# transform normalized counts
norm.counts <- assay(vsd) %>% 
  t() # this is how WGCNA expects to work with the data t() is a transform function

#filter to only look at the samples that we have data for 
# Filter only samples present in norm.counts
ULT_trait <- ULT_trait[rownames(ULT_trait) %in% rownames(norm.counts), , drop = FALSE]

# calculate variance for each gene
gene_vars <- apply(norm.counts, 2, var) # the 2 means to look across columns

# keep top 50% most variable genes (adjust proportion as needed)
n_keep <- floor(length(gene_vars) * 0.5) # floor causes us to round down if we did not have an even number
high_var_genes <- names(sort(gene_vars, decreasing = TRUE))[1:n_keep]

# subset matrix
norm.counts <- norm.counts[, high_var_genes]
```

Setting up soft threshold

```{r}
# Choose a set of soft-thresholding powers
power <- c(c(1:10), seq(from = 12, to = 50, by = 2)) #calculate the networks by a variety of powers
sft <- pickSoftThreshold(norm.counts, 
                         powerVector = power,
                         networkType = "signed", # accounts for positive LFC and negative LFC; generally you want to do signed network type
                         verbose = 5)

sft.data <-sft$fitIndices
#visualization to pick power

a1 <- ggplot(sft.data, aes(Power, SFT.R.sq, label = Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1) +
  geom_hline(yintercept = 0.8, color = 'red') +
  labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
  theme_classic()


a2 <- ggplot(sft.data, aes(Power, mean.k., label = Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1) +
  labs(x = 'Power', y = 'Mean Connectivity') +
  theme_classic()


grid.arrange(a1, a2, ncol = 2)
```
You want an R^2 > 0.8 but you don't want the connectivity to be bottomed out. I am going to go with a beta value of 18.

Network construction

```{r}
# convert matrix to numeric
norm.counts[] <- sapply(norm.counts, as.numeric)
dim(norm.counts) # check dimensions: 
soft_power <- 18 # this is my number!
temp_cor <- cor # base R way for calculating correlation
cor <- WGCNA::cor # WGCNA way for calculating correlation


# memory estimate w.r.t blocksize
bwnet <- blockwiseModules(norm.counts,
                          maxBlockSize = 8000, # we don't want any modules with more than 8000
                          TOMType = "signed",
                          power = soft_power,
                          mergeCutHeight = 0.25,
                          numericLabels = FALSE,
                          randomSeed = 1234,
                          verbose = 3)

# This step takes a while so you can save it here for future work.
save(bwnet, file = "bwnet_results_WGCNA.RData")
load("bwnet_results_WGCNA.RData") #to load the bwnet file back in 

cor <- temp_cor
```

Plot dendrograms of modules

```{r}
module_eigengenes <- bwnet$MEs

# Print out a preview
head(module_eigengenes)

# get number of genes for each module
table(bwnet$colors)

# Plot the dendrogram and the module colors before and after merging underneath
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors),
                    c("unmerged", "merged"),
                    dendroLabels = FALSE,
                    addGuide = TRUE,
                    hang= 0.03,
                    guideHang = 0.05)
```
Th greater the height the lower the correlation. Height of dendrogram represents correlation.

Test for a correlation between each eigengene of each module and our ULT trait data

```{r}
# Define numbers of genes and samples
nSamples <- nrow(norm.counts) #
nGenes <- ncol(norm.counts) #


# correlation between module eigengenes and trait (ULT)
module.trait.corr <- cor(module_eigengenes, ULT_trait, use = 'p') # uses pearson's correlation
module.trait.corr.pvals <- corPvalueStudent(module.trait.corr, nSamples)

# merge eigengenes with trait data
heatmap.data <- merge(module_eigengenes, ULT_trait, by = "row.names") %>%
  column_to_rownames(var = "Row.names")

# automatically detect eigengene and trait columns
eigengene_cols <- grep("^ME", colnames(heatmap.data), value = TRUE)
trait_cols <- colnames(ULT_trait)

# plot correlations
CorLevelPlot(heatmap.data,
             x = trait_cols,
             y = eigengene_cols,
             col = c("blue1", "skyblue", "white", "pink", "red"))
```
The heat map values -0.4 to +0.4 are the degree of correlation


Plot the eigengene values by treatment and line conditions

```{r}
module.gene.mapping <- as.data.frame(bwnet$colors) # assigns module membership to each gene
module.gene.mapping %>% 
  filter(`bwnet$colors` == 'midnightblue') %>% 
  rownames()

groups <- conds[,c(1,2)] # uses conditions of the trait data
module_eigengene.metadata <- merge(groups, heatmap.data, by = 'row.names')

library(Rmisc)
#Create a summary data frame of a particular module eigengene information
MEmidnightblue_summary <- summarySE(module_eigengene.metadata, measurevar="MEmidnightblue", groupvars=c("generation","line"))

#Plot a line interaction plot of a particular module eigengene
ggplot(MEmidnightblue_summary, aes(x=as.factor(generation), y=MEmidnightblue, color=line, fill = line, shape = line)) +
  geom_point(size=5, stroke = 1.5 ) +
  geom_errorbar(aes(ymin=MEmidnightblue-se, ymax=MEmidnightblue+se), width=.15) +
  geom_line(aes(color=line, group=line, linetype = line)) +
  scale_color_manual(values = c('blue', "red")) +
  scale_shape_manual(values=c(21,23), labels = c("Ambient","22 at G1"))+
  scale_fill_manual(values=c('blue',"red"), labels = c("Ambient","22 at G1"))+
  xlab("Generation") +
  theme_bw() +
  theme(legend.position = "none") +
  theme(panel.border = element_rect(color = "black", fill = NA, size = 4))+
  theme(text = element_text(size = 20)) +
  theme(panel.grid.minor.y = element_blank(), legend.position = "none", plot.margin = margin(0,6,0,6))
```

Using tonsaGO to figure out which GO terms are included in the midnightblue category

```{r}
# Read GO terms file (tonsa_go) provided in 
tonsa_go <- read.delim("Genes_GO_terms_output.tsv", header = TRUE) %>%
  slice(-c(1,2)) %>%  # remove header rows if present
  na.omit()  # remove missing GO annotations

# Choose which module to explore -- change the name here
geneIDs_midnightblue <- module.gene.mapping %>% filter(`bwnet$colors` == 'midnightblue') %>% rownames()

# Filter annotation for module genes -- change the name here
module_GO <- tonsa_go[tonsa_go$geneID %in% geneIDs_midnightblue, ]

go_terms <- module_GO$GO

# Split by semicolon and flatten
go_split <- unlist(strsplit(go_terms, ";"))

# Get unique GO categories
unique_go <- unique(go_split)

# print as a clean list
cat(unique_go, sep = "\n")
```
This output can be inputted into REVIGO.
